#!/bin/bash

# show help message
getopt_assert -?:--help "$@"
if [[ $? == 0 ]]; then
	echo 'usage symlink-reflow [-?|--help] [-c:--cygwin] [-f:--force]
Convert cygwin symlinks to Windows NTFS links and vice versa

-f, --force           do not prompt before each relink
-c, --cygwin          convert to cygwin symlinks (default is windows links)
-?, --help            display this message'
	exit 0
fi

# Spaces do not count as new delimiters
IFS=$'\n'
# keep reference to where we are now
CURRENT_PWD="$(pwd)"

# see if we want to convert to a windows link or a cygwin link
LINK_TYPE="winlink"
getopt_assert -c:--cygwin "$@"
if [[ $? == 0 ]]; then
	LINK_TYPE="cyglink"
fi

# see if we have to ask for each symlink
FORCE=
getopt_assert -f:--force "$@"
if [[ $? == 0 ]]; then
	FORCE=1
fi

# make windows ntfs symlinks
function winlink () {
	local LINK OPTIONS LASTMODTIME TARGET DIRNAME BASENAME
	# params
	LINK="$1"
	OPTIONS=$2
	LASTMODTIME="$(find "$LINK" -maxdepth 0 -printf "%t")"
	TARGET="$(readlink "$LINK")"
	DIRNAME="$(dirname "$LINK")"
	BASENAME="$(basename "$LINK")"

	if [[ -n $(confirm "$LINK" "$TARGET") ]]; then
		return 0
	fi

	# delete the existing link
	rm -f "$LINK"

	# we want to make relative links whenever possible, so we should try going going into the directory first
	cd "$DIRNAME"

	if [[ ${TARGET:0:1} == "/" ]]; then
		# if absolute path then run it against cygpath
		cmd /c mklink $OPTIONS "$BASENAME" "$(cygpath -wa "$TARGET")"
	else
		# otherwise replace unix path separator with windows versions
		cmd /c mklink $OPTIONS "$BASENAME" "${TARGET//\//\\}"
	fi

	# give the new link the same file mod time as the previous link
	touch -h -d "$LASTMODTIME" "$BASENAME"

	# go back to the previous working directory
	cd "$CURRENT_PWD"
}

# make cygwin symlinks
function cyglink () {
	local LINK LASTMODTIME TARGET DIRNAME BASENAME
	# params
	LINK="$1"
	LASTMODTIME="$(find "$LINK" -maxdepth 0 -printf "%t")"
	TARGET="$(readlink "$LINK")"
	DIRNAME="$(dirname "$LINK")"
	BASENAME="$(basename "$LINK")"

	if [[ -n $(confirm "$LINK" "$TARGET") ]]; then
		return 0
	fi

	# delete the existing link
	rm -f "$LINK"

	# we want to make relative links whenever possible, so we should try going going into the directory first
	cd "$DIRNAME"

	# otherwise replace unix path separator with windows versions
	ln -s "$TARGET" "$BASENAME"
	if [[ $? == 0 ]]; then
		echo "symbolic link created for $LINK <<===>> $TARGET"
	fi

	# give the new link the same file mod time as the previous link
	touch -h -d "$LASTMODTIME" "$BASENAME"

	# go back to the previous working directory
	cd "$CURRENT_PWD"
}

# confirm that we want to create a symlink
function confirm () {
	# do we need to prompt?
	if [[ -z $FORCE ]]; then
		read -p "Relink '$1' => '$2'? " CONFIRM
		if [[ $CONFIRM != y* ]]; then
			echo "1"
			return;
		fi
	fi
}

# Relink all directories
for dir in $(find "$CURRENT_PWD" -type l -print0 | xargs -0 -i find -L {} -type d -maxdepth 0)
do
	$LINK_TYPE "$dir" /D
done

# Relink all files
for file in $(find "$CURRENT_PWD" -type l -print0 | xargs -0 -i find -L {} -type f -maxdepth 0)
do
	$LINK_TYPE "$file"
done
